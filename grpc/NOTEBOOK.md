# NOTEBOOK

## Overarching Design Decisions
1. Using gRPC for communication between the client and the server - gRPC is a high-performance, open-source framework for building remote procedure call (RPC) APIs. gRPC allows us to define service methods and message types in a simple definition language, which can then be used to generate client and server code in a variety of programming languages. Using gRPC made it easy to define the service methods and data types, and the generated code provides a simple and efficient way to communicate between the client and the server. 
2. Using the `defaultdict` data structure to store connected users and their messages - the `defaultdict` data structure is a subclass of the built-in `dict` type that provides a default value for a nonexistent key. Using a `defaultdict` with a default value of an empty list made it easy to store the messages for each user. When a new user is added, their messages list is automatically created with an empty list. When a message is sent to a user who does not exist, the default value of an empty list is returned.
3. Using separate methods for handling various commands sent by the client - instead of having a single method to handle all commands, we defined separate methods to handle each command (e.g., `command_join()`, `command_list()`, `command_delete()`, etc.). This made the code more modular and easier to maintain. It also made it easier to add new commands in the future.
4. Starting a separate thread to continuously listen for pending messages - when a client sends a message to another client who is not currently connected, the message is stored as a pending message for that client. We started a separate thread to continuously listen for pending messages and display them to the user. This allows the user to receive messages even when they are not actively sending messages to the server.
5. Using a well-defined protocol for client-server communication - we defined a clear protocol for communication between the client and the server. This made it easier to understand how the system works and to implement the client and server applications. It also makes it easier to add new features or modify existing ones in the future.
6. Using a dictionary to map commands to functions - we defined a dictionary `actions` in the `Chat` class that maps commands to the corresponding functions (e.g., `command_join()` for the "join" command). This made it easy to add new commands and functions in the future without modifying the core code.
7. Using thread-safe data structures - since the server handles multiple client connections simultaneously, it was important to use thread-safe data structures to ensure that data is accessed and modified in a safe and synchronized way. 
8. Using separate methods for handling gRPC service methods - in the `Chat` class, we defined separate methods for handling the three gRPC service methods (`Listen()`, `Packet()`, and `Chat()`). This made the code more modular and easier to read and understand.
9. Handling errors and exceptions gracefully - throughout the code, we made an effort to handle errors and exceptions in a graceful way that does not crash the application or leave it in an inconsistent state. For example, when a user attempts to delete a non-existent user, we return an error message instead of crashing the application. This improves the reliability and robustness of the code.


## Server Deep Dive
1. `users = defaultdict(list)` was created to store all the connected users and their messages. We chose to use the `defaultdict` data structure as it simplifies the creation of keys for which values do not yet exist.
2. `get_pending_messages()` method was defined to retrieve pending messages for a user, if any exist. The method first checks if the user exists in the `users` dictionary. If it does not exist, it returns an empty list. If it exists, it returns the messages associated with that user.
3. `clear_pending_messages()` method was defined to remove all pending messages associated with a user. It first checks if the user exists in the `users` dictionary. If it does exist, it clears the messages. If it does not exist, it does nothing.
4. `return_pending_messages()` method was defined to return pending messages and then clear the messages associated with a user. It first checks if the user exists in the `users` dictionary. If it does exist, it returns the messages associated with that user and clears them. If it does not exist, it returns an empty list.
5. `delete_user()` method was defined to delete a user from the `users` dictionary. It first checks if the user exists in the `users` dictionary. If it does, it deletes the user and returns `True`. If it does not exist, it returns `False`.
6. `command_join()` method was defined to create a user if it does not already exist in the `users` dictionary, and add it to the dictionary if it does not exist. If it does exist, it returns a message welcoming the user back.
7. `command_list()` method was defined to retrieve a list of all users in the `users` dictionary. It takes an optional `wildcard` parameter, which filters the list of users based on the given string. The method returns a comma-separated list of usernames.
8. `command_delete()` method was defined to delete a user from the `users` dictionary. It first checks if the user exists in the `users` dictionary. If it does, it deletes the user and returns a message saying the user has been deleted. If it does not exist, it returns a message saying the user does not exist.
9. `send()` method was defined to send a message from one user to another. It first checks if the recipient user exists in the `users` dictionary. If it does not exist, it returns an error message. If it exists, it adds the message to the list of messages for the recipient.
10. `Chat` class was defined that inherits from `chatapp_pb2_grpc.ChatServiceServicer`. It contains three methods: `Listen()`, `Packet()`, and `Chat()`.
11. `Listen()` method was defined to retrieve pending messages for a user. It calls the `return_pending_messages()` method to retrieve the messages and creates a response that includes the messages and a boolean flag indicating if the list of messages is empty.
12. `Packet()` method was defined to execute a command sent by a client. It first retrieves the action to be taken from the request object. It then retrieves the username from the request object. It then calls the appropriate command method (e.g., `command_join()`, `command_list()`, etc.) based on the action, and returns the response.
13. `Chat()` method was defined to handle sending a message from one user to another. It retrieves the sender, receiver, and message from the request object and calls the `send()` method to send the message. It returns a response indicating if the message was sent successfully.
14. `main()` method was defined to start the gRPC server. It first creates an instance of the `grpc.server()` class and sets the maximum number of workers to 10. It then adds the `Chat` class as a servicer to the server. It then starts the server by calling the `start()` method and passes in the host and port. It also prints a message indicating that the server is listening. If a `KeyboardInterrupt` exception is raised, it stops the server and prints a message indicating that the server has stopped.

## Client Deep Dive
1. `get_username()` method was defined to retrieve a username from the user. It continuously prompts the user for input until a non-empty string is entered. It then returns the username.
2. `join_chat()` method was defined to create a new user or login an existing user. It sends a "join" command to the server using the gRPC stub and returns the response.
3. `listen_to_pending_messages()` method was defined to retrieve pending messages from the server and print them to the console. It continuously calls the `Listen()` method on the server using the gRPC stub until an exception is raised.
4. `list_command()` method was defined to retrieve a list of users from the server. It takes an optional `wildcard` parameter, which filters the list of users based on the given string. It sends a "list" command to the server using the gRPC stub and prints the response to the console.
5. `send_command()` method was defined to send a message from one user to another. It takes a list of command arguments, which includes the recipient user. It prompts the user for a message to send and sends the message to the recipient using the `Chat()` method on the server using the gRPC stub.
6. `delete_command()` method was defined to delete a user from the server. It takes a list of command arguments, which includes the user to be deleted. It sends a "delete" command to the server using the gRPC stub and prints the response to the console.
7. `quit_command()` method was defined to logout the user from the server. It sends a "logout" command to the server using the gRPC stub and returns the response.
8. `main()` method was defined to start the client application. It first creates a gRPC channel to the server using the host and port. It then prompts the user for a username and joins the chat using the `join_chat()` method. It starts a separate thread to continuously listen for pending messages using the `listen_to_pending_messages()` method. It then displays a list of available commands to the user and continuously prompts the user for input. If the user enters a valid command, it calls the appropriate method to execute the command. If the user enters "logout", it logs out the user and stops the application.

## Comparison vs. Wire Protocol
1. In terms of code complexity, implementing a wire protocol was more complex than gRPC because it requires low-level socket programming to handle the connection and data exchange. With a wire protocol, you need to define the message format, handle message parsing, and implement error handling yourself. On the other hand, gRPC provides a high-level interface that abstracts away many of the low-level details and makes it easier to write and maintain code
2. Regarding performance, gRPC is slightly faster than the wire protocol because it uses Protocol Buffers, a binary serialization format, which can be more efficient in terms of both speed and size. In contrast, wire protocols usually use textual or binary formats that may be less efficient. Additionally, gRPC uses HTTP/2 as the underlying transport protocol, which can multiplex multiple streams over a single connection, reducing latency and improving throughput.
3. We found that gRPC messages are smaller in size than wire protocol messages due to the use of binary serialization and compression techniques. As a result, gRPC can be more efficient in terms of bandwidth usage.